# Mutex & RwLock

- 回顾
    - `Cell<T>`
    - `RefCell<T>`
- 讲解
    - `Mutex`
    - `RwLock`

## Cell\<T>

由来：

- rust编译器强制约定：对于一个对象`T`，只能存在以下两种情况之一：
    1. 若干个指向该对象的不可变引用(`&T`)
    2. 一个指向该对象的可变引用(`&mut T`)
- 有时这个约定不太好用，所以产生了以下用法：
    - 内部可变性：通过不可变引用来修改其持有的值
- Cell没有实现`Send trait`，所以只能用于单线程

实现原理：

- 通过移动(move)值的方式实现内部可变性
    - 无法获取到内部值的 `&mut T`
    - 也无法直接获取其内部的值，除非用别的值替换它
- 确保不会有多个引用同时指向内部的值

常用方法：

- 针对实现了`Copy`的类型
    - `get`方法可通过复制的方式获取内部的值
- 针对实现了`Default`的类型
    - `take`方法会将当前内部值替换为`Default::default()`，并返回原来的值
- 针对所有类型
    - `Replace`方法，替换当前内部值，返回原来的内部值
    - `into_inner`方法，消耗(consume)掉这个`Cell<T>`，并返回内部值
    - `set`方法，替换当前的内部值，丢弃原来的值

使用场景：

- `Cell<T>`一般用于简单类型(如数值)，因为复制/移动不会太消耗资源
- 可能的情况下优先使用`Cell<T>`而不是其它的Cell类型
- 对于较大或者不可复制(non-copy)的类型，`RefCell`更有优势

## RefCell\<T>

- 与`Cell<T>`不同，`RefCell<T>`允许直接借用它的内部值
    - 有一点运行开销
- `RefCell<T>`不仅持有`T`的值，还持有一个计数器，用来追踪有多少个借用
    - 借用是在运行时被追踪的
    - Rust 原生的引用类型则完全是在编译时静态检查的

常用方法：

- `borrow()`,可以获取对`RefCell`内部值的不可变引用(`&T`)
- `borrow_mut()`,可以获取对`RefCell`内部值的可变引用(`&mut T`)
- 其它
    - `try_borrow(), try_borrow_mut()`: 如果当前`RefCell`已经存在了一个可变引用，此时再调用`borrow()`
      时，因违反了Rust的借用检查器规则(统一时刻只能有一个可变引用和0个不可变引用)，则会`panic`, 所以可以使用`try_borrow`
      则会返回一个`Result`。

借用规则：

- 任意数量的不可变借用(`&T`)
- 或单个可变借用(`&mut T`)
- 违反规则线程会`painc`

## Mutex

互斥锁：一种用于保护共享数据的的互斥原语

- Mutex
    - 最常见的用于在线程间分享(可变)数据的工具
    - 只允许对数据的独占访问
        - 临时阻塞同一时刻想要访问数据的其它线程

两种状态

- 访问数据前要请求锁(lock)。锁定状态 (locked)
- 当请求完成时需要移除锁。未锁定 (unlocked)

- 锁定状态
    - 未锁定(unlocked) -> (执行Lock) -> 锁定(locked)
    - 锁定(locked) -> (执行Lock) -> 阻塞(等待解锁后才能获取到)
- 解锁状态
    - 锁定(locked) -> (执行Unlock) ->未锁定(unlocked)
- 锁中毒状态(Lock Poisoning)
  - 当某个线程在持有`Mutex`锁时发生了`panic`, 这个互斥锁就会被视为已中毒
  - 一旦Mutex中毒
    - 默认情况下，其它线程将无法访问其所保护的数据。因为这些数据很可能已被污染
  - 调用`lock`和`try_lock`方法会返回一个`Result`,用于指示该互斥锁是否已中毒
  - 中毒的`Mutex`并不会阻止对底层数据的所有访问
    - `PoisonError`类型提供了一个`into_inner`方法，可以返回原本在成功加锁时会返回的守卫 、
    - 即使互斥锁已中毒，仍然可以访问到锁保护的数据
## RwLock
读写锁
- `RwLock`允许在统一时刻可以有**多个读取者**或者最多**一个写入者**
- 适用于经常被多线程读取，偶尔更新的场景。

三种状态
- 未锁定
- 由独占的写入者锁定
- 由任意数量的读取者锁定

常用方法
- `std::sync:RwLock<T>`
- 锁定的方法
  - `read()` --> `RwLockReadGuard` (实现了`Deref` trait)
  - `write()` --> `RwLockWriteGuard` (实现了`Deref` & `DefefMut` trait)
- `T`: 必须实现了 `Send` 和 `Sync` 两个trait
  - `Send` trait: 可以允许跨线程传输
  - `Sync` trait: 可以在多个线程之间安全共享引用

实现原理
- `std` 的 `RwLock`：具体实现依赖于操作系统
  - 大多数实现：
    - 如果有写入者在等待，那么就先阻塞新的读取者(即使当前是读取锁定的状态)

中毒状态
- 读写锁(`RwLock`)在发生panic时也可能进入中毒状态
- 但只有当`painc`发生在独占模式(写入模式)下时，读写锁才会被中毒。
- 如果`painc`发生在任意一个读取者中，那么该锁不会被中毒